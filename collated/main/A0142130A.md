# A0142130A
###### \java\seedu\taskell\commons\events\storage\StorageLocationChangedEvent.java
``` java
package seedu.taskell.commons.events.storage;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.events.BaseEvent;

/**
 * Indicates storage location has changed.
 */
public class StorageLocationChangedEvent extends BaseEvent {
    
    private Config config;
    
    public StorageLocationChangedEvent(Config config) {
        this.config = config;
    }
    
    public Config getConfig() {
        return config;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\ClearCommandInputEvent.java
``` java
package seedu.taskell.commons.events.ui;

import seedu.taskell.commons.events.BaseEvent;

/** indicates ClearCommand is being executed
 * */

public class ClearCommandInputEvent extends BaseEvent {

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\DisplayCalendarViewEvent.java
``` java
package seedu.taskell.commons.events.ui;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates display panel needs to show calendar **/

public class DisplayCalendarViewEvent extends BaseEvent {
   
    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }

}
```
###### \java\seedu\taskell\commons\events\ui\DisplayListChangedEvent.java
``` java
package seedu.taskell.commons.events.ui;

import java.util.ArrayList;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates a list needs to be displayed on Display Panel
 * */
public class DisplayListChangedEvent extends BaseEvent {
    
    private ArrayList<String> list;
    
    public DisplayListChangedEvent(ArrayList<String> list) {
        this.list = list;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
    
    public ArrayList<String> getList() {
        return list;
    }

}
```
###### \java\seedu\taskell\commons\events\undo\ExecutedIncorrectCommandEvent.java
``` java
package seedu.taskell.commons.events.undo;

import seedu.taskell.commons.events.BaseEvent;

/** Indicates a Command has been entered incorrectly, to feedback to History
 *  NOTE: this is different from IncorrectCommandAttemptedEvent (which is meant for UI)
 */

public class ExecutedIncorrectCommandEvent extends BaseEvent {
    
    private boolean isUndoableCommand;
    
    public ExecutedIncorrectCommandEvent(boolean isUndoableCommand) {
        this.isUndoableCommand = isUndoableCommand;
    }
    
    public boolean isUndoableCommand() {
        return isUndoableCommand;
    }

    @Override
    public String toString() {
        return this.getClass().getSimpleName();
    }
}
```
###### \java\seedu\taskell\commons\util\StringUtil.java
``` java
    /** checks if source contains query as substring and ignores case
     */
    public static boolean containsSubstringAndIgnoreCase(String source, String query) {
        String[] split = source.toLowerCase().split("\\s+");
        List<String> strings = Arrays.asList(split);
        return strings.stream().filter(s -> s.contains(query.toLowerCase())).count() > 0;
    }
```
###### \java\seedu\taskell\history\CommandHistory.java
``` java
package seedu.taskell.history;

import seedu.taskell.logic.commands.DeleteCommand;
import seedu.taskell.logic.commands.DoneCommand;
import seedu.taskell.logic.commands.UndoneCommand;
import seedu.taskell.model.task.Task;

/** Stores the relevant details of a command so it can be undone via UndoCommand
 *  each Add/Delete/Edit Command executed should correspond to a CommandHistory 
 *  stored in UndoCommand's list of CommandHistory
 * */
public class CommandHistory {
    private String commandText, commandType;
    private Task task;      //relevant task to be added, deleted or edited
    private Task oldTask;   //oldTask needed for EditCommands
    private boolean isRedoCommand;
    
    public CommandHistory() {
        commandText = "default command text";
        commandType = "default command type";
        task = null;
        isRedoCommand = false;
    }
    
    public CommandHistory(String commandText, String commandType) {
        assert commandText != null;
        assert commandType != null;
        assert !commandText.trim().isEmpty();
        assert !commandType.trim().isEmpty();
        
        this.commandText = commandText.trim();
        this.commandType = commandType.trim();
        this.task = null;
        isRedoCommand = false;
    }
    
    public String getCommandText() {
        return commandText;
    }
    
    public String getCommandType() {
        return commandType;
    }
    
    public Task getTask() {
        return task;
    }
    
    public Task getOldTask() {
        return oldTask;
    }
    
    public boolean isRedoTrue() {
        return isRedoCommand;
    }
    
    /**** Setter methods ****/
    
    public void setCommandText(String text) {
        this.commandText = text;
    }
    
    public void setTask(Task task) {
        assert task != null;
        
        this.task = task;
        
        //edits text form to show task description and other parameters
        if (commandType.equals(DeleteCommand.COMMAND_WORD)) {
            commandText = "delete " + this.task.getAsText();
        } else if (commandType.equals(DoneCommand.COMMAND_WORD)) {
            commandText = "done " + this.task.getAsText();
        } else if (commandType.equals(UndoneCommand.COMMAND_WORD)) {
            commandText = "undone " + this.task.getAsText();
        }
    }
    
    public void setOldTask(Task task) {
        this.oldTask = task;
    }
    
    public void setToRedoToTrue() {
        isRedoCommand = true;
    }
    
}
```
###### \java\seedu\taskell\history\History.java
``` java
package seedu.taskell.history;

import java.util.ArrayList;

import seedu.taskell.model.task.Task;

/** API of History, holds command history available for undo
 */
public interface History {
    
    /** Returns list of command history */
    ArrayList<CommandHistory> getList();
    
    /** Returns list of command history text form*/
    ArrayList<String> getListCommandText();
    
    /** Clears internal history */
    void clear();
    
    /** Adds new command to history */
    void addCommand(String commandText, String commandType);
    
    /** Updates most recent command history with the relevant Task created */
    void addTask(Task task);
    
    /** Updates most recent command history with the relevant old Task (for edit commands only)*/
    void addOldTask(Task task);
    
    /** Most recent command is incorrect, needs to be deleted */
    void deleteLatestCommand();

    /** Deletes a given CommandHistory */
    void deleteCommandHistory(CommandHistory commandHistory);

    /** Removes Tasks no longer in system (i.e. user deleted/cleared/edited) */
    void updateHistory();
    
}
```
###### \java\seedu\taskell\history\HistoryManager.java
``` java
package seedu.taskell.history;

import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.logging.Logger;

import com.google.common.eventbus.Subscribe;

import seedu.taskell.commons.core.ComponentManager;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.events.undo.ExecutedIncorrectCommandEvent;
import seedu.taskell.logic.commands.AddCommand;
import seedu.taskell.logic.commands.DoneCommand;
import seedu.taskell.logic.commands.EditCommand;
import seedu.taskell.logic.commands.UndoneCommand;
import seedu.taskell.model.Model;
import seedu.taskell.model.task.Task;

/** Implementation of History API, manages command history available for undo
 *  uses singleton pattern to prevent multiple instantiation
 */
public class HistoryManager extends ComponentManager implements History {

    private static final Logger logger = LogsCenter.getLogger(HistoryManager.class.getName());
    
    private static ArrayList<CommandHistory> historyList;
    private static Model model;
    private static HistoryManager self;
    
    public HistoryManager() {
        historyList = new ArrayList<>();
    }
    
    public static History getInstance() {
        if (self == null) {
            self = new HistoryManager();
        }    
        return self;
    }
    
    public static void setModel(Model m) {
        model = m;
    }
    
    @Override
    public ArrayList<CommandHistory> getList() {
        return historyList;
    }

    @Override
    /** returns list of command history's user input strings
     * */
    public ArrayList<String> getListCommandText() {
        assert historyList != null;
        
        ArrayList<String> list = new ArrayList<>();
        for (CommandHistory history: historyList) {
            list.add(history.getCommandText());
        }
        
        return list;
    }
    
    @Override
    public void updateHistory() {
        try {
            updateList();
        } catch (ConcurrentModificationException e) {
            logger.severe("Concurrent modification exception while updating history");
            updateList();
        }
    }
    
    /** should be called whenever Delete or Edit or Clear is executed
     *  deletes history of the task deleted/edited
     * */
    public synchronized void updateList() throws ConcurrentModificationException {

        if (model == null) {
            logger.severe("Model is null");
            return;
        }
        
        ArrayList<CommandHistory> toRemove = new ArrayList<>();
        
        try {
            for (CommandHistory commandHistory: historyList) {
                if (isUndoCommandTypeAndNeedPresentTask(commandHistory) 
                        && !isTaskPresent(commandHistory.getTask())) {
                    toRemove.add(commandHistory);
                } else if (isRedoCommandTypeAndNeedPresentTask(commandHistory) 
                        && !isTaskPresent(commandHistory.getTask())) {
                    toRemove.add(commandHistory);
                }
            }
        } catch (ConcurrentModificationException e) {
            throw e;
        }
        
        historyList.removeAll(toRemove);
    }
    
    /** checks if type is Add/Edit/Done/Undone that requires a task present in system to work
     * */
    private boolean isUndoCommandTypeAndNeedPresentTask(CommandHistory commandHistory) {
        return (commandHistory.getCommandType().equals(AddCommand.COMMAND_WORD) 
                || commandHistory.getCommandType().equals(EditCommand.COMMAND_WORD)
                || commandHistory.getCommandType().equals(DoneCommand.COMMAND_WORD)
                || commandHistory.getCommandType().equals(UndoneCommand.COMMAND_WORD)) 
                && !commandHistory.isRedoTrue();
    }
    
    /** checks if type is Edit with isRedo set to true
     * */
    private boolean isRedoCommandTypeAndNeedPresentTask(CommandHistory commandHistory) {
        return (commandHistory.getCommandType().equals(EditCommand.COMMAND_WORD)
                || commandHistory.getCommandType().equals(DoneCommand.COMMAND_WORD)
                || commandHistory.getCommandType().equals(UndoneCommand.COMMAND_WORD))
                && commandHistory.isRedoTrue();
    }

    @Override
    public void clear() {
        logger.info("Clearing history...");
        historyList.clear();        
    }

    @Override
    public void addCommand(String commandText, String commandType) {
        assert historyList != null;
        historyList.add(new CommandHistory(commandText, commandType));
        
    }

    @Override
    public void addTask(Task task) {
        logger.info("Adding task to history");
        if (historyList.isEmpty()) {
            logger.warning("No command history to add task to");
            return;
        }
        
        historyList.get(getOffset(historyList.size())).setTask(task);
    }

    @Override
    public void addOldTask(Task task) {
        logger.info("Adding old task to history");
        if (historyList.isEmpty()) {
            logger.warning("No command history to add task to");
            return;
        }
        
        historyList.get(getOffset(historyList.size())).setOldTask(task);
    }

    private boolean isTaskPresent(Task task) {
        return model.isTaskPresent(task);
    }
    
    @Override
    public void deleteLatestCommand() {
        logger.info("Command unsuccessfully executed. Deleting command history.");
        if (historyList.isEmpty()) {
            logger.warning("No command history to delete");
            return;
        }
        historyList.remove(getOffset(historyList.size()));
    }

    @Override
    public void deleteCommandHistory(CommandHistory commandHistory) {
        historyList.remove(commandHistory);
    }
    
    private static int getOffset(int index) {
        return index - 1;
    }

    @Subscribe
    private void handleExecuteIncorrectCommandEvent(ExecutedIncorrectCommandEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        if (event.isUndoableCommand()) {
            deleteLatestCommand();
        }
    }

    
}
```
###### \java\seedu\taskell\logic\commands\ClearCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.ClearCommandInputEvent;
import seedu.taskell.model.TaskManager;

/**
 * Clears the task manager. Will show confirm dialog before clearing.
 */
public class ClearCommand extends Command {

    public static final String COMMAND_WORD = "clear";
    public static final String MESSAGE_SUCCESS = "Clear command executed.";
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Clears all tasks.\n"
            + "Example: " + COMMAND_WORD;
    
    private static ClearCommand self;
    private static boolean isUnderTesting;  //for testing ONLY

    public ClearCommand() {}

    public static ClearCommand getInstance() {
        if (self == null) {
            self = new ClearCommand();
        }
        
        return self;
    }
    
    /** if set to true, ClearCommand bypasses confirm dialog
     *  for running test cases ONLY
     * */
    public static void setIsUnderTesting(boolean value) {
        isUnderTesting = value;
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        
        if (isUnderTesting) {
            executeClear();
        } else {
            raiseClearCommandInputEvent();
        }
        
        return new CommandResult(MESSAGE_SUCCESS);
    }
    
    /** executes reset data
     *  will be called from UiManager after confirmation of clear
     * */
    public void executeClear() {
        model.resetData(TaskManager.getEmptyTaskManager());
        history.updateHistory();
    }

    private void raiseClearCommandInputEvent() {
        EventsCenter.getInstance().post(new ClearCommandInputEvent());      
    }
    
}
```
###### \java\seedu\taskell\logic\commands\FindCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in task manager whose description and tags contains all of the argument keywords.
 * Keyword matching is not case sensitive.
 */
public class FindCommand extends Command {

    public static final String COMMAND_WORD = "find";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose description contains all of "
            + "the specified keywords (not case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " milk bananas chicken";

    private final Set<String> keywords;

    public FindCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskListByAllKeywords(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }

}
```
###### \java\seedu\taskell\logic\commands\FindTagCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.Set;

/**
 * Finds and lists all tasks in task manager whose description contains any of the argument keywords.
 * Keyword matching is not case sensitive.
 */

public class FindTagCommand extends Command {

    public static final String COMMAND_WORD = "find-tag";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Finds all tasks whose description contain any of "
            + "the specified keywords (not case-sensitive) and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " help study homework";

    private final Set<String> keywords;

    public FindTagCommand(Set<String> keywords) {
        this.keywords = keywords;
    }

    @Override
    public CommandResult execute() {
        model.updateFilteredTaskListByAnyKeyword(keywords);
        return new CommandResult(getMessageForTaskListShownSummary(model.getFilteredTaskList().size()));
    }
}
```
###### \java\seedu\taskell\logic\commands\IncorrectCommand.java
``` java
    
    /** for setting latest command as an undoable command, so if command is
     *  input wrongly, its history needs to be deleted
     * */
    public static void setIsUndoableCommand(boolean value) {
        isUndoableCommand = value;
    }
    
    public static boolean isUndoableCommand() {
        return isUndoableCommand;
    }
    
    /** if latest command is an undoable command, need to delete its command history
     * */
    private void indicateExecutedIncorrectCommand() {
        EventsCenter.getInstance().post(new ExecutedIncorrectCommandEvent(isUndoableCommand));
    }

```
###### \java\seedu\taskell\logic\commands\SaveStorageLocationCommand.java
``` java
package seedu.taskell.logic.commands;

import java.io.File;
import java.io.IOException;
import java.util.logging.Logger;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.events.storage.StorageLocationChangedEvent;
import seedu.taskell.commons.exceptions.DataConversionException;
import seedu.taskell.model.ReadOnlyTaskManager;
import seedu.taskell.storage.JsonConfigStorage;
import seedu.taskell.storage.Storage;

/** Saves current data file to new filepath.
 * */

public class SaveStorageLocationCommand extends Command {
    
    private Logger logger = LogsCenter.getLogger(SaveStorageLocationCommand.class.getName());
    
    public static final String COMMAND_WORD = "save";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Saves data file to new location specified. "
            + "New files can be auto-created as long as given directory is valid.\n"
            + "Parameters: FILEPATH (must be valid)\n"
            + "Example: " + COMMAND_WORD + " C:\\Users\\chicken\\Desktop\\cat";
    
    private static final String MESSAGE_SUCCESS = "Data successfully saved to new location.";
    private static final String MESSAGE_INVALID_PATH = "Filepath given is invalid. Filepath will be reset to old path.";
    
    private static Config config;
    private String newStorageFilePath, oldStorageFilePath;
    private ReadOnlyTaskManager taskManager;
    private static JsonConfigStorage jsonConfigStorage;
    private static Storage storage;
    
    public SaveStorageLocationCommand(String newStorageFilePath) {
        this.oldStorageFilePath = config.getTaskManagerFilePath();
        logger.info("Old file path: " + oldStorageFilePath);
        
        this.newStorageFilePath = newStorageFilePath.trim().replace("\\", "/") + "/taskmanager.xml";
        logger.info("New file path: " + this.newStorageFilePath);
        jsonConfigStorage = new JsonConfigStorage(Config.DEFAULT_CONFIG_FILE);
    }
    
    public static void setConfig(Config c) {
        config = c;
    }
    
    public static void setStorage(Storage s) {
        storage = s;
    }

    @Override
    public CommandResult execute() {
        assert config != null;
        assert jsonConfigStorage != null;

        taskManager = model.getTaskManager();
        
        config.setTaskManagerFilePath(newStorageFilePath);
        indicateStorageLocationChanged();
        try {
            storage.saveTaskManager(taskManager, newStorageFilePath);
            storage.readTaskManager();
        } catch (IOException e) {
            handleInvalidFilePathException();
            return new CommandResult(MESSAGE_INVALID_PATH);
        } catch (DataConversionException e) {
            handleInvalidFilePathException();
            return new CommandResult(MESSAGE_INVALID_PATH);
        }
        
        saveToConfigJson();
        
        deleteOldFile();
        
        model.updateFilteredListToShowAll();
        return new CommandResult(MESSAGE_SUCCESS);
    }

    /** deletes xml file in previous storage location
     * */
    private void deleteOldFile() {
        File file = new File(oldStorageFilePath);
        file.delete();
    }

    private void indicateStorageLocationChanged() {
        assert config != null;
        EventsCenter.getInstance().post(new StorageLocationChangedEvent(config));
    }
    
    /** occurs when there is error writing to given filepath
     *  i.e. invalid name, invalid directory
     *  this method will transfer data file back to previous location and 
     *  configure internal variables to point back to correct location
     * */
    private void handleInvalidFilePathException() {
        logger.info("Error writing to filepath. Handling data save exception.");
        assert config != null;
        
        config.setTaskManagerFilePath(oldStorageFilePath);  //set back to old filepath
        indicateStorageLocationChanged();
        
        try {
            storage.saveTaskManager(taskManager, newStorageFilePath);
        } catch (IOException e) {
            logger.severe("Error saving task manager");
        }
        
        saveToConfigJson();
    }
    
    private void saveToConfigJson() {
        try {
            jsonConfigStorage.saveConfigFile(config);
            jsonConfigStorage.readConfigFile();
        } catch (IOException e) {
            logger.severe("save to config json error");
        } catch (DataConversionException e) {
            logger.severe("read back config json error");
        }
    }

}
```
###### \java\seedu\taskell\logic\commands\UndoCommand.java
``` java
package seedu.taskell.logic.commands;

import java.util.ArrayList;
import java.util.logging.Logger;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.events.ui.DisplayListChangedEvent;
import seedu.taskell.history.CommandHistory;
import seedu.taskell.model.task.UniqueTaskList.DuplicateTaskException;
import seedu.taskell.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Undo previously executed commands (add, delete, edit, done, undone)
 * Note: only for current session only (meaning after app is closed, history will be cleared)
 */
public class UndoCommand extends Command {
    private static final Logger logger = LogsCenter.getLogger(UndoCommand.class.getName());
    
    public static final String COMMAND_WORD = "undo";
    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Undo a previously executed command.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 3";
    
    private static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task: %1$s";
    private static final String MESSAGE_ADD_TASK_SUCCESS = "Task added back: %1$s";
    private static final String MESSAGE_EDIT_TASK_SUCCESS = "Task edited back to old version: %1$s";
    
    private static final String MESSAGE_NO_COMMAND_TO_UNDO = "No commands available to undo.";
    public static final String MESSAGE_COMMAND_HISTORY_EMPTY = "No command history available for undo.";
    public static final String MESSAGE_INVALID_INDEX = "Index is invalid.";

    public static final String MESSAGE_DONE_TASK_UNSUCCESSFUL = "The task status is already completed.";
    
    private ArrayList<CommandHistory> commandHistoryList;
    
    private int index;
    private CommandHistory commandHistory;
    
    public UndoCommand(int index) {
        logger.info("Creating UndoCommand with index: " + index);
        
        commandHistoryList = history.getList();
        this.index = index;
    }

    public UndoCommand() {
        logger.info("Creating UndoCommand without index");
        
        commandHistoryList = history.getList();
        this.index = commandHistoryList.size(); //offset will be done in execute()
    }

    @Override
    public CommandResult execute() {
        
        if (commandHistoryList.isEmpty()) {
            return new CommandResult(String.format(MESSAGE_COMMAND_HISTORY_EMPTY));
        } else if (index > commandHistoryList.size()) {
            return new CommandResult(String.format(MESSAGE_INVALID_INDEX));
        }
        
        commandHistory = commandHistoryList.get(getOffset(index));
        
        if (commandHistory.isRedoTrue()) {
            return redoUndo();
        } else {
            return executeUndo();
        }
              
    }

    /** determine type of command of history and performs necessary undo changes
     * */
    private CommandResult executeUndo() {
        String commandType = commandHistory.getCommandType();
        if (commandType.equals(AddCommand.COMMAND_WORD)) {
            return executeDelete();
        } else if (commandType.equals(DeleteCommand.COMMAND_WORD)) {
            return executeAdd();
        } else if (commandType.equals(EditCommand.COMMAND_WORD)) {
            return undoEdit();
        } else if (commandType.equals(DoneCommand.COMMAND_WORD)) {
            return executeUndone();
        } else if (commandType.equals(UndoneCommand.COMMAND_WORD)) {
            return executeDone();
        } else {
            logger.severe("CommandHistory is invalid");
            return new CommandResult(String.format(MESSAGE_NO_COMMAND_TO_UNDO));
        }
    }

    /** must be a previous undo command
     *  determine type of command of history and performs necessary redo changes
     * */
    private CommandResult redoUndo() {
        
        assert commandHistory.isRedoTrue();
        
        String commandType = commandHistory.getCommandType();
        if (commandType.equals(AddCommand.COMMAND_WORD)) {
            return executeAdd();
        } else if (commandType.equals(DeleteCommand.COMMAND_WORD)) {
            return executeDelete();
        } else if (commandType.equals(EditCommand.COMMAND_WORD)) {
            return redoEdit();
        } else if (commandType.equals(DoneCommand.COMMAND_WORD)) {
            return executeDone();
        } else if (commandType.equals(UndoneCommand.COMMAND_WORD)) {
            return executeUndone();
        } else {
            logger.severe("CommandHistory is invalid");
            return new CommandResult(String.format(MESSAGE_NO_COMMAND_TO_UNDO));
        }
        
    }
    
    /** executes undone command on command history
     * */
    private CommandResult executeUndone() {
        try {
            model.editTask(commandHistory.getTask(), commandHistory.getOldTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
            
            return new CommandResult(String.format(UndoneCommand.MESSAGE_UNDONE_TASK_SUCCESS, 
                    commandHistory.getOldTask()));
        } catch (DuplicateTaskException e) {
            history.deleteCommandHistory(commandHistory);
            return new CommandResult(AddCommand.MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
            history.deleteCommandHistory(commandHistory);
            return new CommandResult(UndoneCommand.MESSAGE_UNDONE_UNSUCCESSFUL);
        }
        
    }
    
    /** executes done command on command history
     * */
    private CommandResult executeDone() {
        try {
            model.editTask(commandHistory.getOldTask(), commandHistory.getTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
            
            return new CommandResult(String.format(DoneCommand.MESSAGE_DONE_TASK_SUCCESS, 
                    commandHistory.getTask()));
        } catch (DuplicateTaskException e) {
            history.deleteCommandHistory(commandHistory);
            return new CommandResult(AddCommand.MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
            history.deleteCommandHistory(commandHistory);
            return new CommandResult(MESSAGE_DONE_TASK_UNSUCCESSFUL);
        }
    }

    /** executes edit command on command history, edit back to old task
     * */
    private CommandResult undoEdit() {
        try {
            model.editTask(commandHistory.getTask(), commandHistory.getOldTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, commandHistory.getOldTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(AddCommand.MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        
        assert false: "Undo edit should return a command result";
        return null;
    }
    
    /** executes edit command on command history, edit back to new task
     *  i.e. old task -> new task -> old task
     * */
    private CommandResult redoEdit() {
        try {
            model.editTask(commandHistory.getOldTask(), commandHistory.getTask());
            history.deleteCommandHistory(commandHistory);
            return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, commandHistory.getTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(AddCommand.MESSAGE_DUPLICATE_TASK);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        
        assert false: "Redo edit should return a command result";
        return null;
    }

    /** executes add command on command history
     * */
    private CommandResult executeAdd() {
        try {
            model.addTask(commandHistory.getTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
            return new CommandResult(String.format(MESSAGE_ADD_TASK_SUCCESS, commandHistory.getTask()));
        } catch (DuplicateTaskException e) {
            return new CommandResult(AddCommand.MESSAGE_DUPLICATE_TASK);
        }
    }

    /** executes delete command on command history
     * */
    private CommandResult executeDelete() {
        try {
            model.deleteTask(commandHistory.getTask());
            history.deleteCommandHistory(commandHistory);
            addUndoCommand(commandHistory);
        } catch (TaskNotFoundException e) {
            assert false : "The target task cannot be missing";
        }
        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, commandHistory.getTask()));
    }
    
    /** appends "undo " to front of command input string and saves as an undo command
     *  so that it can execute redo
     * */
    private void addUndoCommand(CommandHistory commandHistory) {
        if (commandHistory.isRedoTrue()) {
            return;
        }
        commandHistory.setCommandText("undo " + commandHistory.getCommandText());
        commandHistory.setToRedoToTrue();
        commandHistoryList.add(commandHistory);
    }
    
    /******** static methods *********/
    
    /** convert 1-based index to support 0-based index within system
     * */
    private static int getOffset(int index) {
        return index - 1;
    }

    /****** Event ******/
    public void indicateDisplayListChanged() {
        EventsCenter.getInstance().post(
                new DisplayListChangedEvent(history.getListCommandText()));
    }
}
```
###### \java\seedu\taskell\logic\commands\ViewCalendarCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.DisplayCalendarViewEvent;

/** Shows calendar view on right panel
 * */
public class ViewCalendarCommand extends Command {
    
    public static final String COMMAND_WORD_1 = "calendar";
    public static final String COMMAND_WORD_2 = "cal";
    
    public static final String MESSAGE_SUCCESS = "Displayed calendar.";
    public static final String MESSAGE_UNSUCCESSFUL = "Error displaying calendar.";

    @Override
    public CommandResult execute() {
        try {
            indicateDisplayCalendarView();
        } catch (Exception e) {
            return new CommandResult(String.format(MESSAGE_UNSUCCESSFUL));
        }
        return new CommandResult(String.format(MESSAGE_SUCCESS));
    }
    
    private void indicateDisplayCalendarView() {
        EventsCenter.getInstance().post(new DisplayCalendarViewEvent());
    }

}
```
###### \java\seedu\taskell\logic\commands\ViewHistoryCommand.java
``` java
package seedu.taskell.logic.commands;

import seedu.taskell.commons.core.EventsCenter;
import seedu.taskell.commons.events.ui.DisplayListChangedEvent;

/** Lists a list of previous commands available for Undo operation
 * */
public class ViewHistoryCommand extends Command {
    
    public static final String COMMAND_WORD_1 = "history";
    public static final String COMMAND_WORD_2 = "hist";

    public static final String MESSAGE_SUCCESS = "Listed all commands available for undo.";
    public static final String MESSAGE_UNSUCCESSFUL = "Error displaying history.";
    
    private static ViewHistoryCommand self;
    
    public ViewHistoryCommand() {}
    
    public static ViewHistoryCommand getInstance() {
        if (self == null) {
            self = new ViewHistoryCommand();
        }
        
        return self;
    }

    @Override
    public CommandResult execute() {
        try {
            indicateDisplayListChanged();
        } catch (Exception e) {
            return new CommandResult(MESSAGE_UNSUCCESSFUL);
        }
        return new CommandResult(MESSAGE_SUCCESS);
    }

    public void indicateDisplayListChanged() {
        EventsCenter.getInstance().post(
                new DisplayListChangedEvent(history.getListCommandText()));
    }

}
```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java

    private Command prepareClear(String arguments) {
        if (arguments.isEmpty()) {
            return new ClearCommand();
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, ClearCommand.MESSAGE_USAGE));
        }

    }

```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java

    /**
     * if type of command is undoable, saves to history for undoing
     */
    private void saveToHistory(String userInput, final String commandWord) {

        if (isUndoableCommandType(commandWord)) {
            IncorrectCommand.setIsUndoableCommand(true);
            history.addCommand(userInput, commandWord);
        } else {
            IncorrectCommand.setIsUndoableCommand(false);
        }
    }

    private boolean isUndoableCommandType(final String commandWord) {
        return commandWord.equals(AddCommand.COMMAND_WORD) || commandWord.equals(DeleteCommand.COMMAND_WORD)
                || commandWord.equals(EditCommand.COMMAND_WORD) || commandWord.equals(DoneCommand.COMMAND_WORD)
                || commandWord.equals(UndoneCommand.COMMAND_WORD);
    }

```
###### \java\seedu\taskell\logic\parser\Parser.java
``` java

    /**
     * Parses arguments in the context of undo command.
     * 
     */
    private Command prepareUndo(String args) {
        if (args.isEmpty()) {
            return new UndoCommand();
        }

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UndoCommand.MESSAGE_USAGE));
        }
        return new UndoCommand(index.get());
    }

    /**
     * Parses arguments in the context of the find task by tags command.
     * 
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareFindByTag(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, FindTagCommand.MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindTagCommand(keywordSet);

    }

    /**
     * Parses arguments in the context of the save storage location command.
     * 
     * @param args
     *            full command args string
     * @return the prepared command
     */
    private Command prepareSaveStorageLocation(String args) {
        if (args.isEmpty()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SaveStorageLocationCommand.MESSAGE_USAGE));
        }
        return new SaveStorageLocationCommand(args);
    }
```
###### \java\seedu\taskell\MainApp.java
``` java

    private void initSaveStorageLocationCommand() {
        SaveStorageLocationCommand.setConfig(config);
        SaveStorageLocationCommand.setStorage(storage);
    }

    private void setDataForClasses() {
        HistoryManager.setModel(model);
        ViewHistoryCommand.getInstance().setData(model);
        ClearCommand.getInstance().setData(model);
        CalendarView.setData(model);
    }
    
```
###### \java\seedu\taskell\MainApp.java
``` java
    @Subscribe
    private void handleStorageLocationChangedEvent(StorageLocationChangedEvent event) {
        logger.info("saving new filepath to storage");
        config = event.getConfig();
        storage.clearTaskManager();
        storage = new StorageManager(config.getTaskManagerFilePath(), config.getUserPrefsFilePath());
        SaveStorageLocationCommand.setStorage(storage);
    }
```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    
    @Override
    public boolean isTaskPresent(Task task) {

        if (task == null) {
            logger.warning("Null task parameter in isTaskPresent()");
            return false;
        }

        return taskManager.isTaskPresent(task);
    }
    
```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    @Override
    public void updateFilteredTaskListByAnyKeyword(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new TagsQualifier(keywords)));
    }

```
###### \java\seedu\taskell\model\ModelManager.java
``` java
        @Override
        public boolean run(ReadOnlyTask task) {
            String searchString = task.getDescription().description + " " + task.tagsSimpleString();
            return nameKeyWords.stream().allMatch(keyword -> StringUtil.containsSubstringAndIgnoreCase(searchString, keyword));
        }

```
###### \java\seedu\taskell\model\ModelManager.java
``` java
    private class TagsQualifier implements Qualifier {
        private Set<String> tagsKeyWords;

        TagsQualifier(Set<String> keyWords) {
            this.tagsKeyWords = keyWords;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return tagsKeyWords.stream()
                    .filter(keyword -> StringUtil.containsSubstringAndIgnoreCase(task.tagsSimpleString(), keyword))
                    .findAny()
                    .isPresent();
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", tagsKeyWords);
        }
    }

```
###### \java\seedu\taskell\model\TaskManager.java
``` java
    public boolean isTaskPresent(Task task) {
        assert task != null;
        return tasks.contains(task);
    }
```
###### \java\seedu\taskell\storage\JsonConfigStorage.java
``` java
package seedu.taskell.storage;

import java.io.File;
import java.io.IOException;
import java.util.Optional;
import java.util.logging.Logger;

import seedu.taskell.commons.core.Config;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.exceptions.DataConversionException;
import seedu.taskell.commons.util.FileUtil;

/**
 * A class to access Config stored in the hard disk as a json file
 */

public class JsonConfigStorage implements ConfigStorage {

    private static final Logger logger = LogsCenter.getLogger(JsonConfigStorage.class);
    
    private String filePath;
    
    public JsonConfigStorage(String filePath) {
        this.filePath = filePath;
    }
    
    @Override
    public Optional<Config> readConfigFile() throws DataConversionException, IOException {
        return readConfig(filePath);
    }

    @Override
    public void saveConfigFile(Config config) throws IOException {
        saveConfig(config, filePath);
    }
    
    /**
     * Similar to {@link #readConfigFile()}
     * @param configFilePath location of the data. Cannot be null.
     * @throws DataConversionException if the file format is not as expected.
     */
    public Optional<Config> readConfig(String configFilePath) throws DataConversionException {
        assert configFilePath != null;

        File configFile = new File(configFilePath);

        if (!configFile.exists()) {
            logger.info("Config file "  + configFile + " not found");
            return Optional.empty();
        }

        Config config;

        try {
            config = FileUtil.deserializeObjectFromJsonFile(configFile, Config.class);
        } catch (IOException e) {
            logger.warning("Error reading from config file " + configFile + ": " + e);
            throw new DataConversionException(e);
        }

        return Optional.of(config);
    }

    /**
     * Similar to {@link #saveConfigFile(Config)}
     * @param configFilePath location of the data. Cannot be null.
     */
    private void saveConfig(Config config, String configFilePath) throws IOException {
        assert config != null;
        assert configFilePath != null;
        assert !configFilePath.isEmpty();

        FileUtil.serializeObjectToJsonFile(new File(configFilePath), config);
    }

}
```
###### \java\seedu\taskell\ui\CalendarView.java
``` java
package seedu.taskell.ui;

import java.util.ArrayList;

import jfxtras.scene.control.agenda.Agenda;
import jfxtras.scene.control.agenda.Agenda.Appointment;
import seedu.taskell.commons.core.UnmodifiableObservableList;
import seedu.taskell.model.Model;
import seedu.taskell.model.task.ReadOnlyTask;
import seedu.taskell.model.task.Task;
import seedu.taskell.model.task.TaskStatus;

/** This class holds the necessary elements to display calendar UI via Agenda API from jfxtras
 * */

public class CalendarView {
    
    private static Model model;
    
    private Agenda agenda;
    
    public CalendarView() {
        agenda = new Agenda();
        setAgendaProperties();
        loadTasks();
    }
    
    public static void setData(Model m) {
        model = m;
    }
    
    public Agenda getAgenda() {
        agenda.appointments().clear();
        loadTasks();
        return agenda;
    }
    
    private void setAgendaProperties() {
        agenda.setAllowDragging(false);
        agenda.setAllowResize(false);
        agenda.setFocusTraversable(false);
        
        agenda.setStyle("-fx-font-size: 12pt");
    }
    
    /** Gets current filtered task list from model and updates agenda's data
     * */
    public void loadTasks() {
        agenda.appointments().clear();

        UnmodifiableObservableList<ReadOnlyTask> taskList = model.getFilteredTaskList();
        
        ArrayList<Appointment> appointments = new ArrayList<>();
        int i=1;
        
        for (ReadOnlyTask task: taskList) {
            
            if (isValidEventTask(task)) {
                appointments.add(new Agenda.AppointmentImplLocal()
                        .withStartLocalDateTime(task.getStartDate().toLocalDateTime(task.getStartTime()))
                        .withEndLocalDateTime(task.getEndDate().toLocalDateTime(task.getEndTime()))
                        .withSummary(String.valueOf(i))
                        .withAppointmentGroup(
                                new Agenda.AppointmentGroupImpl().withStyleClass("group"+i)));
            }
            
            i++;
        }
        
        agenda.appointments().addAll(appointments);
        
    }

    /** Checks that task is incomplete status and is type EventTask
     * */
    private boolean isValidEventTask(ReadOnlyTask task) {
        return task.getTaskStatus().toString().equals(TaskStatus.INCOMPLETE) 
                && task.getTaskType().equals(Task.EVENT_TASK);
    }

}
```
###### \java\seedu\taskell\ui\DisplayPanel.java
``` java
package seedu.taskell.ui;

import javafx.scene.Node;
import javafx.scene.control.TextArea;
import javafx.scene.layout.AnchorPane;
import jfxtras.scene.control.agenda.Agenda;
import seedu.taskell.commons.core.LogsCenter;
import seedu.taskell.commons.util.FxViewUtil;
import seedu.taskell.logic.commands.AddCommand;
import seedu.taskell.logic.commands.HelpCommand;
import seedu.taskell.logic.commands.ViewCalendarCommand;
import seedu.taskell.logic.commands.ViewHistoryCommand;

import java.util.ArrayList;
import java.util.logging.Logger;

/**
 * The Display Panel of the App, on right side of screen
 * shows history or calendar view
 * calendar view is default view
 */
public class DisplayPanel extends UiPart {

    public static final String MESSAGE_NO_HISTORY = "No commands available for undo.";
    public static final String MESSAGE_DISPLAY_HISTORY = "List of command history available for undo:\n";

    private static final String WELCOME_MESSAGE = "Welcome to Taskell!\n"
            + "Enter '" + AddCommand.COMMAND_WORD + "' in command box to add a task.\n"
            + "Enter '" + ViewHistoryCommand.COMMAND_WORD_1 + "' for a list of commands to undo.\n"
            + "Enter '" + ViewCalendarCommand.COMMAND_WORD_1 + "' to view calendar.\n"
            + "Enter '" + HelpCommand.COMMAND_WORD + "' for more information about commands.";

    private static Logger logger = LogsCenter.getLogger(DisplayPanel.class);
    
    public static final String DISPLAY_PANEL_ID = "displayPanel";
    private static final String STATUS_BAR_STYLE_SHEET = "result-display";
    
    private TextArea displayTextArea;
    private CalendarView calendarView;
    private Agenda agenda;

    /**
     * Constructor is kept private as {@link #load(AnchorPane)} is the only way to create a DisplayPanel.
     */
    private DisplayPanel() {
        calendarView = new CalendarView();
        displayTextArea = new TextArea();
        agenda = calendarView.getAgenda();
    }

    @Override
    public void setNode(Node node) {
        //not applicable
    }

    @Override
    public String getFxmlPath() {
        return null; //not applicable
    }

    /**
     * This method should be called after the FX runtime is initialized and in FX application thread.
     * @param placeholder The AnchorPane where the DisplayPanel must be inserted
     */
    public static DisplayPanel load(AnchorPane placeholder){
        logger.info("Initializing displayTextArea panel");
        DisplayPanel displayPanel = new DisplayPanel();
        
        displayPanel.displayTextArea.setEditable(false);
        displayPanel.displayTextArea.setId(DISPLAY_PANEL_ID);
        displayPanel.displayTextArea.getStyleClass().removeAll();
        displayPanel.displayTextArea.getStyleClass().add(STATUS_BAR_STYLE_SHEET);
        
        FxViewUtil.applyAnchorBoundaryParameters(displayPanel.displayTextArea, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(displayPanel.displayTextArea);
        
        displayPanel.displayTextArea.setText(WELCOME_MESSAGE);
       
        displayPanel.displayTextArea.setWrapText(true);
        
        return displayPanel;
    }
    
    /** called whenever history list needs to be shown on display panel
     * */
    public void loadList(AnchorPane placeholder, ArrayList<String> list) {
        placeholder.getChildren().clear();
        placeholder.getChildren().add(displayTextArea);
        
        displayTextArea.setText("");
        if (list.isEmpty()) {
            displayTextArea.setText(MESSAGE_NO_HISTORY);
        }
        else {
            displayTextArea.setText(MESSAGE_DISPLAY_HISTORY);
            for (int i=0; i<list.size(); i++) {
                int index = i+1;
                displayTextArea.appendText(index + ". " + list.get(i) + "\n");
            }
        }
    }
    
    /** default view
     *  clears panel if displayTextArea is showing
     *  fills panel with Agenda for events for the week
     * */
    public void loadCalendar(AnchorPane placeholder) {

        placeholder.getChildren().clear();
        
        agenda = calendarView.getAgenda();
        FxViewUtil.applyAnchorBoundaryParameters(agenda, 0.0, 0.0, 0.0, 0.0);
        placeholder.getChildren().add(agenda);
             
    }
    
```
###### \java\seedu\taskell\ui\MainWindow.java
``` java
    
    public void loadList(ArrayList<String> list) {
        displayPanel.loadList(displayPanelPlaceholder, list);
    }
    
    public void loadCalendarView() {
        displayPanel.loadCalendar(displayPanelPlaceholder);
    }
    
```
###### \java\seedu\taskell\ui\TaskCard.java
``` java
    /** determines if task is complete, to set to darker colour
     * */
    private void setBackgroundColour() {
        if (task.getTaskStatus().toString().equals(TaskStatus.FINISHED)) {
            cardPane.setStyle("-fx-background-color: #4DD0E1"); //cyan 300
        }
    }
```
###### \java\seedu\taskell\ui\UiManager.java
``` java
    
    private Alert showConfirmClearAlertDialogAndWait() {
        return showAlertDialogAndWaitForConfirm(Alert.AlertType.CONFIRMATION, "Clear all tasks?", 
                "Clear all tasks?", "Are you sure you wish to clear all data?");
    }
    
```
###### \java\seedu\taskell\ui\UiManager.java
``` java
    
    @Subscribe
    private void handleDisplayList(DisplayListChangedEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        logger.info("Displaying list...");
        mainWindow.loadList(event.getList());
    }
    
    @Subscribe
    private void handleShowCalendarView(DisplayCalendarViewEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        logger.info("Displaying calendar view...");
        mainWindow.loadCalendarView();
    }
    
    @Subscribe
    private void handleClearCommandInput(ClearCommandInputEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        Alert alert = showConfirmClearAlertDialogAndWait();
        
        if (alert.getResult() == ButtonType.OK) {
            logger.info("clearing");
            ClearCommand.getInstance().executeClear();
        }
    }
    
```
